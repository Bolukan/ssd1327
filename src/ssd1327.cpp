//
// SSD1327 - 128x128x16 grayscale OLED library
// Copyright 2019 (C) BitBank Software, Inc. 
// Project started 6/10/2019
// Written by Larry Bank (bitbank@pobox.com)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <Arduino.h>
#ifdef __AVR__
#include <avr/pgmspace.h>
#endif
#include <BitBang_I2C.h>
#ifndef __AVR_ATtiny85__
#include <Wire.h>
#include <SPI.h>
#endif
#include <ssd1327.h>
void ssd1327Power(byte bOn);
//
// Comment out this line to gain 1K of RAM and not use a backing buffer
//
//#define USE_BACKBUFFER
#ifndef __AVR__
#define USE_BACKBUFFER
#endif // !__AVR__

// small (8x8) font
const byte ucFont[]PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x5f,0x5f,0x06,0x00,0x00,
0x00,0x07,0x07,0x00,0x07,0x07,0x00,0x00,0x14,0x7f,0x7f,0x14,0x7f,0x7f,0x14,0x00,
  0x24,0x2e,0x2a,0x6b,0x6b,0x3a,0x12,0x00,0x46,0x66,0x30,0x18,0x0c,0x66,0x62,0x00,
  0x30,0x7a,0x4f,0x5d,0x37,0x7a,0x48,0x00,0x00,0x04,0x07,0x03,0x00,0x00,0x00,0x00,
  0x00,0x1c,0x3e,0x63,0x41,0x00,0x00,0x00,0x00,0x41,0x63,0x3e,0x1c,0x00,0x00,0x00,
  0x08,0x2a,0x3e,0x1c,0x1c,0x3e,0x2a,0x08,0x00,0x08,0x08,0x3e,0x3e,0x08,0x08,0x00,
  0x00,0x00,0x80,0xe0,0x60,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
  0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x03,0x01,0x00,
  0x3e,0x7f,0x59,0x4d,0x47,0x7f,0x3e,0x00,0x40,0x42,0x7f,0x7f,0x40,0x40,0x00,0x00,
  0x62,0x73,0x59,0x49,0x6f,0x66,0x00,0x00,0x22,0x63,0x49,0x49,0x7f,0x36,0x00,0x00,
  0x18,0x1c,0x16,0x53,0x7f,0x7f,0x50,0x00,0x27,0x67,0x45,0x45,0x7d,0x39,0x00,0x00,
  0x3c,0x7e,0x4b,0x49,0x79,0x30,0x00,0x00,0x03,0x03,0x71,0x79,0x0f,0x07,0x00,0x00,
  0x36,0x7f,0x49,0x49,0x7f,0x36,0x00,0x00,0x06,0x4f,0x49,0x69,0x3f,0x1e,0x00,0x00,
  0x00,0x00,0x00,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x80,0xe6,0x66,0x00,0x00,0x00,
  0x08,0x1c,0x36,0x63,0x41,0x00,0x00,0x00,0x00,0x14,0x14,0x14,0x14,0x14,0x14,0x00,
  0x00,0x41,0x63,0x36,0x1c,0x08,0x00,0x00,0x00,0x02,0x03,0x59,0x5d,0x07,0x02,0x00,
  0x3e,0x7f,0x41,0x5d,0x5d,0x5f,0x0e,0x00,0x7c,0x7e,0x13,0x13,0x7e,0x7c,0x00,0x00,
  0x41,0x7f,0x7f,0x49,0x49,0x7f,0x36,0x00,0x1c,0x3e,0x63,0x41,0x41,0x63,0x22,0x00,
  0x41,0x7f,0x7f,0x41,0x63,0x3e,0x1c,0x00,0x41,0x7f,0x7f,0x49,0x5d,0x41,0x63,0x00,
  0x41,0x7f,0x7f,0x49,0x1d,0x01,0x03,0x00,0x1c,0x3e,0x63,0x41,0x51,0x33,0x72,0x00,
  0x7f,0x7f,0x08,0x08,0x7f,0x7f,0x00,0x00,0x00,0x41,0x7f,0x7f,0x41,0x00,0x00,0x00,
  0x30,0x70,0x40,0x41,0x7f,0x3f,0x01,0x00,0x41,0x7f,0x7f,0x08,0x1c,0x77,0x63,0x00,
  0x41,0x7f,0x7f,0x41,0x40,0x60,0x70,0x00,0x7f,0x7f,0x0e,0x1c,0x0e,0x7f,0x7f,0x00,
  0x7f,0x7f,0x06,0x0c,0x18,0x7f,0x7f,0x00,0x1c,0x3e,0x63,0x41,0x63,0x3e,0x1c,0x00,
  0x41,0x7f,0x7f,0x49,0x09,0x0f,0x06,0x00,0x1e,0x3f,0x21,0x31,0x61,0x7f,0x5e,0x00,
  0x41,0x7f,0x7f,0x09,0x19,0x7f,0x66,0x00,0x26,0x6f,0x4d,0x49,0x59,0x73,0x32,0x00,
  0x03,0x41,0x7f,0x7f,0x41,0x03,0x00,0x00,0x7f,0x7f,0x40,0x40,0x7f,0x7f,0x00,0x00,
  0x1f,0x3f,0x60,0x60,0x3f,0x1f,0x00,0x00,0x3f,0x7f,0x60,0x30,0x60,0x7f,0x3f,0x00,
  0x63,0x77,0x1c,0x08,0x1c,0x77,0x63,0x00,0x07,0x4f,0x78,0x78,0x4f,0x07,0x00,0x00,
  0x47,0x63,0x71,0x59,0x4d,0x67,0x73,0x00,0x00,0x7f,0x7f,0x41,0x41,0x00,0x00,0x00,
  0x01,0x03,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,0x41,0x41,0x7f,0x7f,0x00,0x00,0x00,
  0x08,0x0c,0x06,0x03,0x06,0x0c,0x08,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
  0x00,0x00,0x03,0x07,0x04,0x00,0x00,0x00,0x20,0x74,0x54,0x54,0x3c,0x78,0x40,0x00,
  0x41,0x7f,0x3f,0x48,0x48,0x78,0x30,0x00,0x38,0x7c,0x44,0x44,0x6c,0x28,0x00,0x00,
  0x30,0x78,0x48,0x49,0x3f,0x7f,0x40,0x00,0x38,0x7c,0x54,0x54,0x5c,0x18,0x00,0x00,
  0x48,0x7e,0x7f,0x49,0x03,0x06,0x00,0x00,0x98,0xbc,0xa4,0xa4,0xf8,0x7c,0x04,0x00,
  0x41,0x7f,0x7f,0x08,0x04,0x7c,0x78,0x00,0x00,0x44,0x7d,0x7d,0x40,0x00,0x00,0x00,
  0x60,0xe0,0x80,0x84,0xfd,0x7d,0x00,0x00,0x41,0x7f,0x7f,0x10,0x38,0x6c,0x44,0x00,
  0x00,0x41,0x7f,0x7f,0x40,0x00,0x00,0x00,0x7c,0x7c,0x18,0x78,0x1c,0x7c,0x78,0x00,
  0x7c,0x78,0x04,0x04,0x7c,0x78,0x00,0x00,0x38,0x7c,0x44,0x44,0x7c,0x38,0x00,0x00,
  0x84,0xfc,0xf8,0xa4,0x24,0x3c,0x18,0x00,0x18,0x3c,0x24,0xa4,0xf8,0xfc,0x84,0x00,
  0x44,0x7c,0x78,0x4c,0x04,0x0c,0x18,0x00,0x48,0x5c,0x54,0x74,0x64,0x24,0x00,0x00,
  0x04,0x04,0x3e,0x7f,0x44,0x24,0x00,0x00,0x3c,0x7c,0x40,0x40,0x3c,0x7c,0x40,0x00,
  0x1c,0x3c,0x60,0x60,0x3c,0x1c,0x00,0x00,0x3c,0x7c,0x60,0x30,0x60,0x7c,0x3c,0x00,
  0x44,0x6c,0x38,0x10,0x38,0x6c,0x44,0x00,0x9c,0xbc,0xa0,0xa0,0xfc,0x7c,0x00,0x00,
  0x4c,0x64,0x74,0x5c,0x4c,0x64,0x00,0x00,0x08,0x08,0x3e,0x77,0x41,0x41,0x00,0x00,
  0x00,0x00,0x00,0x77,0x77,0x00,0x00,0x00,0x41,0x41,0x77,0x3e,0x08,0x08,0x00,0x00,
  0x02,0x03,0x01,0x03,0x02,0x03,0x01,0x00,0x70,0x78,0x4c,0x46,0x4c,0x78,0x70,0x00};
  // 5x7 font (in 6x8 cell)
const byte ucSmallFont[]PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x5f,0x06,0x00,0x00,0x07,0x03,0x00,
0x07,0x03,0x00,0x24,0x7e,0x24,0x7e,0x24,0x00,0x24,0x2b,0x6a,0x12,0x00,0x00,0x63,
0x13,0x08,0x64,0x63,0x00,0x36,0x49,0x56,0x20,0x50,0x00,0x00,0x07,0x03,0x00,0x00,
0x00,0x00,0x3e,0x41,0x00,0x00,0x00,0x00,0x41,0x3e,0x00,0x00,0x00,0x08,0x3e,0x1c,
  0x3e,0x08,0x00,0x08,0x08,0x3e,0x08,0x08,0x00,0x00,0xe0,0x60,0x00,0x00,0x00,0x08,
  0x08,0x08,0x08,0x08,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,
  0x00,0x3e,0x51,0x49,0x45,0x3e,0x00,0x00,0x42,0x7f,0x40,0x00,0x00,0x62,0x51,0x49,
  0x49,0x46,0x00,0x22,0x49,0x49,0x49,0x36,0x00,0x18,0x14,0x12,0x7f,0x10,0x00,0x2f,
  0x49,0x49,0x49,0x31,0x00,0x3c,0x4a,0x49,0x49,0x30,0x00,0x01,0x71,0x09,0x05,0x03,
  0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x06,0x49,0x49,0x29,0x1e,0x00,0x00,0x6c,0x6c,
  0x00,0x00,0x00,0x00,0xec,0x6c,0x00,0x00,0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x24,
  0x24,0x24,0x24,0x24,0x00,0x00,0x41,0x22,0x14,0x08,0x00,0x02,0x01,0x59,0x09,0x06,
  0x00,0x3e,0x41,0x5d,0x55,0x1e,0x00,0x7e,0x11,0x11,0x11,0x7e,0x00,0x7f,0x49,0x49,
  0x49,0x36,0x00,0x3e,0x41,0x41,0x41,0x22,0x00,0x7f,0x41,0x41,0x41,0x3e,0x00,0x7f,
  0x49,0x49,0x49,0x41,0x00,0x7f,0x09,0x09,0x09,0x01,0x00,0x3e,0x41,0x49,0x49,0x7a,
  0x00,0x7f,0x08,0x08,0x08,0x7f,0x00,0x00,0x41,0x7f,0x41,0x00,0x00,0x30,0x40,0x40,
  0x40,0x3f,0x00,0x7f,0x08,0x14,0x22,0x41,0x00,0x7f,0x40,0x40,0x40,0x40,0x00,0x7f,
  0x02,0x04,0x02,0x7f,0x00,0x7f,0x02,0x04,0x08,0x7f,0x00,0x3e,0x41,0x41,0x41,0x3e,
  0x00,0x7f,0x09,0x09,0x09,0x06,0x00,0x3e,0x41,0x51,0x21,0x5e,0x00,0x7f,0x09,0x09,
  0x19,0x66,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x01,0x01,0x7f,0x01,0x01,0x00,0x3f,
  0x40,0x40,0x40,0x3f,0x00,0x1f,0x20,0x40,0x20,0x1f,0x00,0x3f,0x40,0x3c,0x40,0x3f,
  0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x07,0x08,0x70,0x08,0x07,0x00,0x71,0x49,0x45,
  0x43,0x00,0x00,0x00,0x7f,0x41,0x41,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00,
  0x41,0x41,0x7f,0x00,0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x80,0x80,0x80,0x80,0x80,
  0x00,0x00,0x03,0x07,0x00,0x00,0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x7f,0x44,0x44,
  0x44,0x38,0x00,0x38,0x44,0x44,0x44,0x28,0x00,0x38,0x44,0x44,0x44,0x7f,0x00,0x38,
  0x54,0x54,0x54,0x08,0x00,0x08,0x7e,0x09,0x09,0x00,0x00,0x18,0xa4,0xa4,0xa4,0x7c,
  0x00,0x7f,0x04,0x04,0x78,0x00,0x00,0x00,0x00,0x7d,0x40,0x00,0x00,0x40,0x80,0x84,
  0x7d,0x00,0x00,0x7f,0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x7f,0x40,0x00,0x00,0x7c,
  0x04,0x18,0x04,0x78,0x00,0x7c,0x04,0x04,0x78,0x00,0x00,0x38,0x44,0x44,0x44,0x38,
  0x00,0xfc,0x44,0x44,0x44,0x38,0x00,0x38,0x44,0x44,0x44,0xfc,0x00,0x44,0x78,0x44,
  0x04,0x08,0x00,0x08,0x54,0x54,0x54,0x20,0x00,0x04,0x3e,0x44,0x24,0x00,0x00,0x3c,
  0x40,0x20,0x7c,0x00,0x00,0x1c,0x20,0x40,0x20,0x1c,0x00,0x3c,0x60,0x30,0x60,0x3c,
  0x00,0x6c,0x10,0x10,0x6c,0x00,0x00,0x9c,0xa0,0x60,0x3c,0x00,0x00,0x64,0x54,0x54,
  0x4c,0x00,0x00,0x08,0x3e,0x41,0x41,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x00,
  0x41,0x41,0x3e,0x08,0x00,0x02,0x01,0x02,0x01,0x00,0x00,0x3c,0x26,0x23,0x26,0x3c};

// some globals
static int iCSPin, iDCPin, iResetPin;
static int iScreenOffset; // current write offset of screen data
#ifdef USE_BACKBUFFER
static unsigned char ucScreen[1024]; // local copy of the image buffer
#endif
static int oled_flip, oled_addr;
static int iSDAPin, iSCLPin;
#define MAX_CACHE 32
static byte bCache[MAX_CACHE] = {0x40}; // for faster character drawing
static byte bEnd = 1;
static void ssd1327WriteCommand(unsigned char c);

// use only the bitbang version on ATtiny85 to avoid linking wire library
#ifdef __AVR_ATtiny85__
static void _I2CWrite(unsigned char *pData, int iLen)
{
  I2CWrite(oled_addr, pData, iLen);
} /* _I2CWrite() */
#else
// Wrapper function to write I2C data on Arduino
static void _I2CWrite(unsigned char *pData, int iLen)
{
  if (iCSPin != -1) // we're writing to SPI, treat it differently
  {
    digitalWrite(iDCPin, (pData[0] == 0) ? LOW : HIGH); // data versus command
    digitalWrite(iCSPin, LOW);
#ifdef HAL_ESP32_HAL_H_ 
   {
   uint8_t ucTemp[1024];
        SPI.transferBytes(&pData[1], ucTemp, iLen-1);
   }
#else
    SPI.transfer(&pData[1], iLen-1);
#endif
    digitalWrite(iCSPin, HIGH);
  }
  else // must be I2C
  {
    if (iSDAPin != -1 && iSCLPin != -1)
    {
       I2CWrite(oled_addr, pData, iLen);
    }
    else
    {
       Wire.beginTransmission(oled_addr);
       Wire.write(pData, iLen);
       Wire.endTransmission();
    }
  } // I2C
} /* _I2CWrite() */
#endif // !__AVR_ATtiny85__

// For SH1106 read_modify_write() operation
static void _I2CRead(unsigned char *pData, int iLen)
{
    if (iSDAPin != -1 && iSCLPin != -1)
    {  
       I2CRead(oled_addr, pData, iLen);
    }
#ifndef __AVR_ATtiny85__
    else
    {  
       Wire.requestFrom(oled_addr, iLen);
       while (iLen)
       {
         *pData++ = Wire.read();
         iLen--;
       }
    }
#endif
} /* _I2CRead() */

static void oledCachedFlush(void)
{
       _I2CWrite(bCache, bEnd); // write the old data
#ifdef USE_BACKBUFFER
       memcpy(&ucScreen[iScreenOffset], &bCache[1], bEnd-1);
       iScreenOffset += (bEnd - 1);
#endif
       bEnd = 1;
} /* oledCachedFlush() */

static void oledCachedWrite(byte *pData, byte bLen)
{

   if (bEnd + bLen > MAX_CACHE) // need to flush it
   {
       oledCachedFlush(); // write the old data
   }
   memcpy(&bCache[bEnd], pData, bLen);
   bEnd += bLen;
  
} /* oledCachedWrite() */
//
// Turn off the display
//
void oledShutdown(void)
{
uint8_t uc[2];

    uc[0] = 0; // command
    uc[1] = 0xae; // display off
    _I2CWrite(uc, 2);

} /* oledShutdown() */
#ifndef __AVR_ATtiny85__
//
// Initialize the OLED controller for SPI mode
//
void ssd1327SPIInit(int iDC, int iCS, int iReset, int bFlip, int bInvert, int32_t iSpeed)
{
uint8_t uc[32], *s;
int iLen;

  iDCPin = iDC;
  iCSPin = iCS;
  iResetPin = iReset;
  oled_flip = bFlip;

  pinMode(iDCPin, OUTPUT);
  pinMode(iCSPin, OUTPUT);
  digitalWrite(iCSPin, HIGH);

  // Reset it
  if (iResetPin != -1)
  {
    pinMode(iResetPin, OUTPUT); 
    digitalWrite(iResetPin, HIGH);
    delay(50);
    digitalWrite(iResetPin, LOW);
    delay(50);
    digitalWrite(iResetPin, HIGH);
    delay(10);
  }
// Initialize SPI
  SPI.begin();
  SPI.beginTransaction(SPISettings(iSpeed, MSBFIRST, SPI_MODE0));
//  SPI.setClockDivider(16);
//  SPI.setBitOrder(MSBFIRST);
//  SPI.setDataMode(SPI_MODE0);

  ssd1327Power(1);

  if (bInvert)
  {
    uc[0] = 0; // command
    uc[1] = 0xa7; // invert command
    _I2CWrite(uc, 2);
  }
  if (bFlip) // rotate display 180
  {
    uc[0] = 0; // command
    uc[1] = 0xa0;
    _I2CWrite(uc, 2);
    uc[0] = 0;
    uc[1] = 0xc0;
    _I2CWrite(uc, 2);
  }

} /* ssd1327SPIInit() */
#endif
//
// Initializes the OLED controller
//
void ssd1327Init(int iAddr, int bFlip, int bInvert, int sda, int scl, int32_t iSpeed)
{
unsigned char uc[4];

  oled_addr = iAddr;
  oled_flip = bFlip;
  iSDAPin = sda;
  iSCLPin = scl;
// Disable SPI mode code
  iCSPin = iDCPin = iResetPin = -1;

if (sda != -1 && scl != -1)
{
  I2CInit(sda, scl, iSpeed);
}
#ifndef __AVR_ATtiny85__
else
{
  Wire.begin(); // Initiate the Wire library
  Wire.setClock(iSpeed); // use high speed I2C mode (default is 100Khz)
}
#endif
  ssd1327Power(1); // turn on the power
  uc[0] = 0x00; // command
  uc[1] = 0xa0; // GDDRAM mapping
  if (bFlip)
     uc[2] = 0x40;
  else
     uc[2] = 0x53; // default (top to bottom, left to right mapping)
  _I2CWrite(uc, 3);
  if (bInvert)
  {
    uc[0] = 0; // command
    uc[1] = 0xa7; // invert command
    _I2CWrite(uc, 2);
  }
} /* ssd1327Init() */
//
// Sends a command to turn on or off the OLED display
//
void ssd1327Power(byte bOn)
{
    if (bOn)
      ssd1327WriteCommand(0xaf); // turn on OLED
    else
      ssd1327WriteCommand(0xae); // turn off OLED
} /* oledPower() */

// Send a single byte command to the OLED controller
static void ssd1327WriteCommand(unsigned char c)
{
unsigned char buf[2];

  buf[0] = 0x00; // command introducer
  buf[1] = c;
  _I2CWrite(buf, 2);
} /* ssd1327WriteCommand() */

static void ssd1327WriteCommand2(unsigned char c, unsigned char d)
{
unsigned char buf[3];

  buf[0] = 0x00;
  buf[1] = c;
  buf[2] = d;
  _I2CWrite(buf, 3);
} /* ssd1327WriteCommand2() */

//
// Send commands to position the "cursor" (aka memory write address)
// to the given row and column as well as the ending col/row
//
static void ssd1327SetPosition(uint8_t x, uint8_t y, uint8_t cx, uint8_t cy)
{
unsigned char buf[8];

#ifdef USE_BACKBUFFER 
  iScreenOffset = (y*64)+x;
#endif
  buf[0] = 0x00; // command introducer
  buf[1] = 0x15; // column start/end
  buf[2] = x/2; // start address
  buf[3] = ((x+cx)/2)-1; // end address
  buf[4] = 0x75; // row start/end
  buf[5] = y; // start row
  buf[6] = y+cy-1; // end row
  _I2CWrite(buf, 7);
} /* ssd1327SetPosition() */

//
// Write a block of pixel data to the OLED
// Length can be anything from 1 to 8192 (whole display)
//
static void ssd1327WriteDataBlock(unsigned char *ucBuf, int iLen)
{
unsigned char ucTemp[129];

  ucTemp[0] = 0x40; // data command
// Copying the data has the benefit in SPI mode of not letting
// the original data get overwritten by the SPI.transfer() function
  memcpy(&ucTemp[1], ucBuf, iLen);
  _I2CWrite(ucTemp, iLen+1);
  // Keep a copy in local buffer
#ifdef USE_BACKBUFFER
  memcpy(&ucScreen[iScreenOffset], ucBuf, iLen);
  iScreenOffset += iLen;
#endif
} /* ssd1327WriteDataBlock() */

// Set an individual pixel to a specific color
// A compromise to avoid needing an 8K back buffer
// A pair of pixels (a byte) is set
// The 128x128 display is remapped as 64x128
void ssd1327SetPixel(int x, int y, unsigned char ucColor)
{
uint8_t ucTemp[2];

  ssd1327SetPosition(x*2, y, 2, 1);
  ucTemp[0] = 0x40; // data
  ucTemp[1] = ucColor | (ucColor << 4);
  _I2CWrite(ucTemp, 2);
} /* ssd1327SetPixel() */

#ifdef FUTURE
//
// Load a 128x64 1-bpp Windows bitmap
// Pass the pointer to the beginning of the BMP file
// First pass version assumes a full screen bitmap
//
int oledLoadBMP(byte *pBMP)
{
int16_t i16;
int iOffBits, q, y, j; // offset to bitmap data
int iPitch;
byte x, z, b, *s;
byte dst_mask;
byte ucTemp[16]; // process 16 bytes at a time
byte bFlipped = false;

  i16 = pgm_read_word(pBMP);
  if (i16 != 0x4d42) // must start with 'BM'
     return -1; // not a BMP file
  i16 = pgm_read_word(pBMP + 18);
  if (i16 != 128) // must be 128 pixels wide
     return -1;
  i16 = pgm_read_word(pBMP + 22);
  if (i16 != 64 && i16 != -64) // must be 64 pixels tall
     return -1;
  if (i16 == 64) // BMP is flipped vertically (typical)
     bFlipped = true;
  i16 = pgm_read_word(pBMP + 28);
  if (i16 != 1) // must be 1 bit per pixel
     return -1;
  iOffBits = pgm_read_word(pBMP + 10);
  iPitch = 16;
  if (bFlipped)
  { 
    iPitch = -16;
    iOffBits += (63 * 16); // start from bottom
  }

// rotate the data and send it to the display
  for (y=0; y<8; y++) // 8 lines of 8 pixels
  {
     oledSetPosition(0, y);
     for (j=0; j<8; j++) // do 8 sections of 16 columns
     {
         s = &pBMP[iOffBits + (j*2) + (y * iPitch*8)]; // source line
         memset(ucTemp, 0, 16); // start with all black
         for (x=0; x<16; x+=8) // do each block of 16x8 pixels
         {
            dst_mask = 1;
            for (q=0; q<8; q++) // gather 8 rows
            {
               b = pgm_read_byte(s + (q * iPitch));
               for (z=0; z<8; z++) // gather up the 8 bits of this column
               {
                  if (b & 0x80)
                      ucTemp[x+z] |= dst_mask;
                  b <<= 1;
               } // for z
               dst_mask <<= 1;
            } // for q
            s++; // next source byte
         } // for x
         oledWriteDataBlock(ucTemp, 16);
     } // for j
  } // for y
  return 0;
} /* oledLoadBMP() */
#endif // FUTURE
//
// Draw a string of normal (8x8), small (6x8) or large (16x32) characters
// At the given col+row
//
void ssd1327WriteString(uint8_t x, uint8_t y, char *szMsg, uint8_t iSize, uint8_t ucFG, uint8_t ucBG)
{
int i, iFontOff;
int tx, ty;
unsigned char uc, ucMask;
unsigned char c, *s, *d, ucTemp2[8], ucTemp[40];

    if (iSize == FONT_NORMAL || iSize == FONT_SMALL) // 8x8 and 6x8 font
    {
       uint8_t cx = (iSize == FONT_NORMAL) ? 8:6;
       uint8_t *pFont = (iSize == FONT_NORMAL) ? ucFont:ucSmallFont;
       i = 0;
       while (x < 128-7 && szMsg[i] != 0)
       {
         ssd1327SetPosition(x, y, cx, 8);
         c = (unsigned char)szMsg[i];
         iFontOff = (int)(c-32) * cx;
         // we can't directly use the pointer to FLASH memory, so copy to a local buffer
         memcpy_P(ucTemp2, &pFont[iFontOff], cx);
         s = ucTemp2;
         d = &ucTemp[0];
         *d++ = 0x40; // data introducer
         ucMask = 1;
         for (ty=0; ty<8; ty++)
         {
           for (tx=0; tx<cx; tx+=2)
           {
              if (s[tx] & ucMask)
                 uc = ucFG;
              else
                 uc = ucBG;
              if (s[tx+1] & ucMask)
                 uc |= (ucFG << 4);
              else
                 uc |= (ucBG << 4);
              *d++ = uc; // store pixel pair
           } // for tx
           ucMask <<= 1;
         } // for ty
         _I2CWrite(ucTemp, 1+(cx*4)); // write character pattern
         x += cx;
         i++;
       }
    }
    else if (iSize == FONT_LARGE) // 16x16 font
    {
      i = 0;
      while (x < 128-15 && szMsg[i] != 0)
      {
// stretch the 'normal' font instead of using the big font
          int tx, ty;
          c = szMsg[i] - 32;
          unsigned char ucMask;
          s = (unsigned char *)&ucFont[(int)c*8];
          memcpy_P(ucTemp2, s, 8);
          ssd1327SetPosition(x, y, 16, 16);
          ucFG |= (ucFG << 4); // 2 pixels at a time
          ucBG |= (ucBG << 4);
          // Stretch the font to double width + double height
          ucTemp[0] = 0x40; // start of data (write one row at a time)
          ucMask = 1;
          for (ty=0; ty<8; ty++)
          {
              for (tx=0; tx<8; tx++)
              {
                  if (ucTemp2[tx] & ucMask) // pixel set
                     c = ucFG;
                  else
                     c = ucBG;
                  ucTemp[1+tx] = ucTemp[1+tx+8] = c; // double it vertically
              }
              _I2CWrite(ucTemp, 17); // write 2 rows of the character
              ucMask <<= 1;
          }
          x += 16;
          i++;
       }
    }
} /* ssd1327WriteString() */
#ifdef FUTURE
//
// Dump a screen's worth of data directly to the display
// Try to speed it up by comparing the new bytes with the existing buffer
//
void oledDumpBuffer(uint8_t *pBuffer)
{
int x, y;
int iLines, iCols;
uint8_t bNeedPos;
#ifdef USE_BACKBUFFER
uint8_t *pSrc = ucScreen;
#endif

  iLines = (oled_type == OLED_128x32 || oled_type == OLED_64x32) ? 4:8;
  iCols = (oled_type == OLED_64x32) ? 4:8;
  for (y=0; y<iLines; y++)
  {
    bNeedPos = 1; // start of a new line means we need to set the position too
    for (x=0; x<iCols; x++) // wiring library has a 32-byte buffer, so send 16 bytes so that the data prefix (0x40) can fit
    {
#ifdef USE_BACKBUFFER
      if (memcmp(pSrc, pBuffer, 16) != 0) // doesn't match, need to send it
#else
      if (1)
#endif
      {
        if (bNeedPos) // need to reposition output cursor?
        {
           bNeedPos = 0;
           oledSetPosition(x*16, y);
        }
        oledWriteDataBlock(pBuffer, 16);
      }
      else
      {
         bNeedPos = 1; // we're skipping a block, so next time will need to set the new position
      }
#ifdef USE_BACKBUFFER
      pSrc += 16;
#endif
      pBuffer += 16;
    } // for x
  } // for y

} /* oledDumpBuffer() */
#endif // FUTURE
//
// Sets the brightness (0=off, 255=brightest)
//
void ssd1327SetContrast(unsigned char ucContrast)
{
  ssd1327WriteCommand2(0x81, ucContrast);
} /* ssd1327SetContrast() */

//
// Fill the frame buffer with a byte pattern
// e.g. all off (0x00) or all on (0xff)
//
void ssd1327Fill(unsigned char ucColor)
{
uint8_t x, y;
uint8_t iLines, iCols;
unsigned char temp[16];

  ucColor |= (ucColor << 4); // set pixel pair color
  memset(temp, ucColor, 16);
 
  ssd1327SetPosition(0,0,128,128);
  for (y=0; y<128; y++)
  {
    for (x=0; x<4; x++)
    {
      ssd1327WriteDataBlock(temp, 16); 
    } // for x
  } // for y
#ifdef USE_BACKBUFFER
   memset(ucScreen, ucData, 1024);
#endif
} /* ssd1327Fill() */

#ifdef USE_BACKBUFFER
void oledDrawLine(int x1, int y1, int x2, int y2)
{
  int temp, i;
  int dx = x2 - x1;
  int dy = y2 - y1;
  int error;
  byte *p, *pStart, mask, bOld, bNew;
  int xinc, yinc;
  int y, x;
  
  if (x1 < 0 || x2 < 0 || y1 < 0 || y2 < 0 || x1 > 127 || x2 > 127 || y1 > 63 || y2 > 63)
     return;

  if(abs(dx) > abs(dy)) {
    // X major case
    if(x2 < x1) {
      dx = -dx;
      temp = x1;
      x1 = x2;
      x2 = temp;
      temp = y1;
      y1 = y2;
      y2 = temp;
    }

    y = y1;
    dy = (y2 - y1);
    error = dx >> 1;
    yinc = 1;
    if (dy < 0)
    {
      dy = -dy;
      yinc = -1;
    }
    p = pStart = &ucScreen[x1 + ((y >> 3) << 7)]; // point to current spot in back buffer
    mask = 1 << (y & 7); // current bit offset
    for(x=x1; x1 <= x2; x1++) {
      *p++ |= mask; // set pixel and increment x pointer
      error -= dy;
      if (error < 0)
      {
        error += dx;
        if (yinc > 0)
           mask <<= 1;
        else
           mask >>= 1;
        if (mask == 0) // we've moved outside the current row, write the data we changed
        {
           oledSetPosition(x, y>>3);
           oledWriteDataBlock(pStart,  (int)(p-pStart)); // write the row we changed
           x = x1+1; // we've already written the byte at x1
           y1 = y+yinc;
           p += (yinc > 0) ? 128 : -128;
           pStart = p;
           mask = 1 << (y1 & 7);
        }
        y += yinc;
      }
    } // for x1    
   if (p != pStart) // some data needs to be written
   {
     oledSetPosition(x, y>>3);
     oledWriteDataBlock(pStart, (int)(p-pStart));
   }
  }
  else {
    // Y major case
    if(y1 > y2) {
      dy = -dy;
      temp = x1;
      x1 = x2;
      x2 = temp;
      temp = y1;
      y1 = y2;
      y2 = temp;
    } 

    p = &ucScreen[x1 + ((y1 >> 3) * 128)]; // point to current spot in back buffer
    bOld = bNew = p[0]; // current data at that address
    mask = 1 << (y1 & 7); // current bit offset
    dx = (x2 - x1);
    error = dy >> 1;
    xinc = 1;
    if (dx < 0)
    {
      dx = -dx;
      xinc = -1;
    }
    for(x = x1; y1 <= y2; y1++) {
      bNew |= mask; // set the pixel
      error -= dx;
      mask <<= 1; // y1++
      if (mask == 0) // we're done with this byte, write it if necessary
      {
        if (bOld != bNew)
        {
          p[0] = bNew; // save to RAM
          oledSetPosition(x, y1>>3);
          oledWriteDataBlock(&bNew, 1);
        }
        p += 128; // next line
        bOld = bNew = p[0];
        mask = 1; // start at LSB again
      }
      if (error < 0)
      {
        error += dy;
        if (bOld != bNew) // write the last byte we modified if it changed
        {
          p[0] = bNew; // save to RAM
          oledSetPosition(x, y1>>3);
          oledWriteDataBlock(&bNew, 1);         
        }
        p += xinc;
        x += xinc;
        bOld = bNew = p[0];
      }
    } // for y
    if (bOld != bNew) // write the last byte we modified if it changed
    {
      p[0] = bNew; // save to RAM
      oledSetPosition(x, y2>>3);
      oledWriteDataBlock(&bNew, 1);        
    }
  } // y major case
} /* oledDrawLine() */
#endif // USE_BACKBUFFER

